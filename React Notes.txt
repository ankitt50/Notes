************************************REACT*******************************************************************
************************************************************************************************************


************************************REACT BASICS AND WORKING WITH COMPONENTS**************************************
******************************************************************************************************************


React - It is a JS library to build User Interfaces
		It is all about components.Bcoz, all UIs are in the end made up of components.
		
		Components : Reusability, and Separation of concerns.
		
		--> to create and start react app :
		
			npm install -g create-react-app
			npx create-react-app my-app
			cd my-app
			npm start
			
			npm install command is used to reinstall/install all the dependencies.
			These downloaded/installed dependenies can be seen in the node_module folder.
			
			index.js file is the first file to be executed.
			index.html file contains the "root" element of the react-app.
			
			JSX : HTML code inside javascript code. 
			
			Declarative approach is used for React components. We just define the state of elements and let the React 
			figure out the actual JS DOM instructions.
			The other approach is called "Imperative" approach. This is used in plain vanilla JS. We have to give clear step by step instructions
			regarding the DOM manipulation.
			
			Component in React is a JavaScript function. This function's return statement must have only one root element.
			
		--> We can use "props" for passing data to any component.
			
			** Inside {} we can write any JS code.
			** We can name the parameter anything, but as a convention, we use "props" as a name.
			
			
			function ExpenseItem(props) {
				return {
					<div ..... >
					<div>{props.title}</div>
					....
					....
					....
					</div>
				}
			}
			
			
			<ExpenseItem 
			title = {expenses[0].title}
			></ExpenseItem>
			
			** there is a special prop called "children". Don't define it like an attribute, but have to wrap it inside the component.
			
			function Card(props) {
			return {
			<div className="Card">{props.children}</div>
			}
			}
			
			<Card>
			<div>.......</div>
			....
			....
			...
			</Card>
			
		--> JSX 
			
			Under the hood :
			
				React.createElement(
				'div',
				{},
				React.createElement(
				'h2',
				{},"Let's get started"),
				React.createElement(
				'Expense',
				{items: expenses}
				)
				);
			
			JSX Code that we write :
			
				<div>
					<h2>Let's get started</h2>
					<Expense items={expenses}/>
				</div>
				

************************************REACT STATE AND WORKING WITH EVENTS**************************************
******************************************************************************************************************

		--> Adding event listener to a button :
			
			<button onclick={() => {Console.log('Clicked!')}}></button>
			
			<button onclick={clickHandler}>Click me</button>
			
			const clickHandler =() => {
				Console.log('Clicked');
			};
		
		--> "State" in React :
		
				import React, {useState} from 'react'; //useState is a react hook. It is called directly inside the react component function.
				
				const [title, setTitle] = useState('defaultTitle');
				// the default Title value provided is used only the first time the component is rendered.
				// When the component is re-rendered after the setTitle method call, the title value provided is 
				// the new updated value, which can be used inside the component.
				
				const clickHandler = () => {
					setTitle("UpdatedTitle"); // setTitle don't just change the value of title variable. It is a special function to 
											  // also render the component again with the new updated title value
											  // Also the value of the variable is not changed right away, but is scheduled to be
											  // changed.
					// state is managed on per component instance basis. So, changes in one of the instance of a component
					// will not be reflected on other instances of that same component.
					// Also state used to manage any one variable of a component will not affect state used for any other
					// variable of that same component.
				};
				
				return (
				..
				..
				..
				<h2>{title}</h2>
				..
				..
				..
				);
				
		--> working with forms :
		
				const [enteredTitle, setEnteredTitle] = setState('');
				
				
				
				titleChangeHandler = (event) => {
					Console.log(event.target.value);
					setEnteredTitle(event.target.value);
					// to save the entered title in a variable,
					// which can be used later, when user submits the form.
				};
				
				
				const formSubmitHandler = (event) => {
					event.preventDefault(); // to prevent submission of page to the server and reloading of the page.
					..
					..
					..
					..
				};
				
				<form onSubmit={formSubmitHandler}>
					<div className="..">
						<label>Title</label>
						<input type="text" value={enteredTitle} onChange={titleChangeHandler}/>
					</div>
					<div className="..">
						<label>Amount</label>
						<input type="number" min="" step="" />
					</div>
					<div className="..">
						<label>Date</label>
						<input type="date" min="" max="" />
					</div>
					<div>
						<button type="Submit">Submit</button>
					</div>
				</form>
				
				** Adding "enteredTitle" as value in the text field, which we are getting useState, leads to two way binding.
				
				** to pass data from child to parent component, we can pass a function as a prop from parent to child. This
				function can be called from child whenever we need.
				
				** Lifting state up : If we have to pass data between components that don't have parent-child relation, then we have to
				   first pass data from child to parent (i.e lifting up) and then parent to the component to which we have to finally 
				   pass the data to.
				   
				** Controlled Component : Whenever there is a two-way binding between child and parent component, then child component is called
										  Controlled component. In two way binding, the child component passes the data (on Change only) 
										  to the parent through a method, and parent passes the same data/variable as a prop to the child.
				
				
				
************************************RENDERING LISTS AND CONDITIONAL CONTENT**************************************
******************************************************************************************************************

		--> Rendering a list of data :
				
				{props.events.map(event => <ExpenseItem key={expense.id} title={expense.title} ...... />)}
				
				** always add "key" when rendering a list.
				
		--> Outputting Conditional components :
		
			{filteredExpenses.length === 0 ? (<p>No content to display</p>) : 
			(
				filteredExpenses.map(expense => <ExpenseItem key= {} ....... />)
			)
			}
				
				
				(or)
				
			{filteredExpenses.length === 0  && (<p>No content to display</p>) }
			{filteredExpenses.length > 0  && (
				filteredExpenses.map(expense => <ExpenseItem key= {} ....... />)
			)}
			
			 (or)
			 
			 const expenseContent = <p>No content to display</p> ;
			 
			 if(filteredExpenses.length > 0) {
				expenseContent = filteredExpenses.map(expense => <ExpenseItem key= {} ....... /> ;
			 }
			 
			 return (
			 ..
			 ..
			 ..
			 {expenseContent}
			 ..
			 .
			 .
			 );


************************************STYLING REACT COMPONENTS**************************************
****************************************************************************************************************** 
			 
		--> Dynamic Inline Style
				
				ex: <label style={{color: !isValid ? 'red' : 'black'}}> Some Label Text </label>
			
					<input style={
					{
						borderColor : !isValid ? 'red' : 'black',
						background: !isValid > 'Salmon' : 'transparent'
					}
					}
					type="text" onChange={someHandler} />
			 
		--> Dynamically setting CSS classes
		
				<div className={`form-input ${!isValid ? 'invalid' : ''}`} >
					....
				</div>
				
				
				in CSS file :
					
					.form-control.invalid label {
						color: 'red'
					}
					
					.form-control.invalid input {
						borderColor: 'red',
						background: 'Salmon'
					}
					
		--> Styled Components 
				
				npm install --save styled-components
				
				** used to prevent spill overs i.e. no other component should be affected, if by mistake we have used multiple
					components with the same class name. styled-component package provides a unique class name for all the components
					which have used it for styling.
					
				** We can also pass props to the styled component methods for dynamic styling.
				
		    ** We can also achive the same using "CSS modules" in react.
			
************************************Diving Deeper: working with Fragments, Portals and "Refs"**************************************
****************************************************************************************************************** 
	
		--> JSX limitations : can't have more than one element adjacent to another when returning them from a component.
							  
							  We generally use a wrapping "div" at top level. 
							  We can also wrap these adjacent elements inside an array. But always add "key" attribute for each of these elements.
							  But with these wrapping "div", we have a new problem called "<div> Soup".
							  This means there are all these wrapping elements which are now being rendered, but don't have any usage.
							  
							  We can also create a custom component, which just returns the childrens and nothing else.
							  Then this component can be used to wrap the adjacent components/elements.
							  
							  function Wrapper(props) {
								
								return props.children;
								
							  }
							  
							  
			React Fragments : provided by react to wrap around adjacent elements.
							
							<React.Fragment>
								<h2>.....</h2>
								<p>.....</p>
							</React.Fragment>
							  
							  
							  (or)
							  
							<>
								<h2>.....</h2>
								<p>.....</p>
							</>
							
			
			React Portals :
							
							If we are creating a "Modal" component/ Side Menu Component/ or any overlay component. Its not a good practice to
							write/render (in final DOM) the component side-by-side other Components. It although works fine, but is not a good practice.
							
							
							create new div elements in the index.html :						
							
							<body>
								...
								....
								<div id="backdrop-root"></div>
								<div id="overlay-root"></div>
								<div id="root"></div>
							</body>
							
							
							
							inside the ErrorModal component return : 
							
							<React.Fragment>
							{ 
							
							ReactDOM.createPortal(
								<Backdrop onConfirm={props.onConfirm} />, // This is your custom modal component
								document.getElementById('backdrop-root')
							)
							
							}
							>/React.Fragment>
							
			
			"Refs" :    import {useState, useRef} from 'react';
						
						It is another hook provided by react library.
						
						const nameInputRef = useRef();
						
						
						<input
							id="username"
							type="text"
							value={enteredUsername}
							onChange={usernameChangeHandler} --> this will not be required, once we use "ref"
							ref = {nameInputRef}
							
						/>
						
						
						
						cont submitBtnHandler = (event) => {
						
						event.preventDefault;
						....
						....
						...
						console.log(nameInputRef.current.value);
						}
						
						
						** Using refs instead of useState hooks, gives us direct access to the real DOM, and we are not using 
						react to manipulate or read from the element.
						Also, the input elements now becomes uncontrolled.
						
						** It is generally not a good practice to work with real DOM element directly to manipulate them.
						Although reading from them isn't a big issue.
			
							
************************************Advanced: Handling Side effects, using reducers and using the context API**************************************
****************************************************************************************************************** 

		--> Effect (or "Side Effect") : main job of react application is to render UI and react to User Input.
										Anything else, which is not concerned with UI rendering/re-rendering is "Side Effect"
										ex: Store data, send Http requests, timers, etc.
										These tasks must happen outside of the normal component evaluation. As they might delay the rendering.
										
										So,for this we can use "useEffect()" hook of the react.
													
			
									localStorage.setItem('isLoggedIn','1');
									localStorage.removeItem('isLoggedIn');
									
									const storedUserLoggedInInformation = localStorage.getItem('isLoggedIn');
									
									if (storedUserLoggedInInformation === '1') {
										setIsLoggedIn(true); // Using useState  will create a infinite loop.
															// everytime we call setIsLoggedIn, the component will be re-rendered and the 
															// if loop will again be executed and again the setIsLoggedIn function will
															// be called.
									}
									
									we can wrap this inside the "useEffect" hook, if we want it to run/execute just once.
									
									useEffect(
										() => {
										
										
										const storedUserLoggedInInformation = localStorage.getItem('isLoggedIn');
									
										if (storedUserLoggedInInformation === '1') {
										setIsLoggedIn(true); 
										}
										
											`
										}, []);
										
									
									useEffect can also be used to execute only if a dependency is changes.
									
									useEffect(
										() => {
										setFormIsvalid(enteredEmail.includes('@') && eneteredPassword.trim().length > 6);`
										}, [enteredEmail, eneteredPassword]);
										
									
									** don't add state updating functions as dependencies inside the useEffect.
									** don't add "built-in" APIs or functions.
									** don't add variables/functions defined outside of your component. Such functions/variables are not
									   created inside of a component function and hence changing them won't affect your components.
									  
									** In short, add anything that could change because your component re-rendered.
						
	
			
								** useEffect cleanup -> for example we want to check if the user entered email is valid or not. Then we don't have to check it after every keystroke.
														Or if we want to check if the entered username already exists or not in the DB? We should not ideally be sending request to the server after 
														every keystroke. Instead, it would be better if we check the user input after the user has stopped typing for some seconds.
														This is called de-bounsing.
														With useEffect, it is very easy to implement.
														
														ex : 
														
														useEffect(
														
														() => {
														
															const identifier = setTimeout(()=> {
																console.log('Checking for validity');
																setFormIsValid()
															}, 500);
														
														
														// cleanup function : It is executed before the use effect will be executed again next time.
														// So, it run before the useEffect function everytime, except for the very first time.
														return () => {
															clearTimeout(identifier);
														}
														},[enteredEmail,eneteredPassword]);
														
		
		
		--> useReducer() for state management : It can be used when the state management for any variable is more complex and useState() becomes more error prone.
		
												import React, {useState, useEffect, useReducer} from 'react';
												
												const[state, dispatchFn] = useReducer(reducerFn, initialState, initFn);
												
												
												// this function is defined outside the component
												const emailReducer = (state,action) => {
													if(action.type === 'USER_INPUT') {
													// action represents the new user entered values.
														return {value: action.val, isValid: action.val.includes('@')}; 
													}
													if(action.type === 'INPUT_BLUR') {
													// state represents the current state, and is guaranteed to be the latest by react.
														return {value: state.value, isValid: state.value.includes('@')}; 
													}
													return {value: '', isValid: false};
												};
												
												const Login = (props) => {
													
													const[emailState, dispatchEmail] = useReducer(emailReducer, {value: '', isValid: false});
													
													
													...
													...
													...
													
													const emailChangeHandler = (event) => {
														dispatchEmail({type: 'USER_INPUT', val: event.target.value});
														...
														...
														...
													}
													
													const passwordChangeHandler = (event) => {
														setEnteredPassword(event.target.value);
														setFormIsValid(
															emailState.value.includes('@') && event.target.value.trim().length > 6
															
															(or)
															
															emailState.isValid && event.target.value.trim().length > 6
														);
													}
													
													const validateEmailHandler = () => {
														dispatchEmail({type:'INPUT_BLUR'});
													}
													
													const {isValid: emailIsValid } = emailState; // destructuring the object and giving it an alias "emailIsValid"
													const{isValid: passwordIsValid} = passwordState;
													
													useEffect(
														() => {
															const identifier = setTimeout(() => {
																setFormIsValid(emailIsValid && passwordIsValid);
															},500);
															
															return () => {
																clearTimeout(identifier);
															}
														}, [emailIsValid,passwordIsValid ]
													);
													
												
												}
		
		
		--> React Context APi : component-wide, "behind-the-scenes" state storage.
								It helps in cases where we have to pass data from one component to too many components.
								
								In "auth-context.js" file :
								
								import React from 'react';
								
								const AuthContext = React.createContext(
								{
									isLoggedIn: false
								}
								);
								
								export default AuthContext;
								
								
								In "App.js" file :
								
								import AuthContext from 'auth-context';
								
								
								retun (
								<React.Fragment>
								<AuthContext.Provider
									value={
										{
											isLoggedIn: isLoggedIn
										}
									}
								>
									<MainHeader .......... />
									<main>
										{ !isLoggedIn && <Login ......./> }
										{ isLoggedIn && <Home ......./> }
									</main>
								<AuthContext.Provider>
								</React.Fragment>
								)
								
								
								In "Navigation.js" file :
								
								const Navigation = (props) => {
									<AuthContext.Consumer>
									{
										(ctx) => {
											return (
												<nav .....>
												<ul>
													{ctx.isLoggedIn && (
														<li> <a href="/">Users</a>
													)}
												..
												...
												...
												..
												</nav>
											)
										}
									}
										
									</AuthContext.Consumer>
								}
								
								
								Alternative way is using "useContext()" hook, instead of the AuthContext.Consumer
								
								const Navigation = (props) => {
								
								const ctx = useContext(AuthContext);
									
											return (
												<nav .....>
												<ul>
													{ctx.isLoggedIn && (
														<li> <a href="/">Users</a>
													)}
												..
												...
												...
												..
												</nav>
											)
										
								}
								
				
				Alternate to using the AppContext.Provider in the App.js file is to create a custom context provider :
				
				
						in the "auth-context.js" file :
						
						import React, { useState, useEffect } from 'react';

						const AuthContext = React.createContext({
						  isLoggedIn: false,
						  onLogout: () => {},
						  onLogin: (email, password) => {}
						});

						export const AuthContextProvider = (props) => {
						  const [isLoggedIn, setIsLoggedIn] = useState(false);

						  useEffect(() => {
							const storedUserLoggedInInformation = localStorage.getItem('isLoggedIn');

							if (storedUserLoggedInInformation === '1') {
							  setIsLoggedIn(true);
							}
						  }, []);

						  const logoutHandler = () => {
							localStorage.removeItem('isLoggedIn');
							setIsLoggedIn(false);
						  };

						  const loginHandler = () => {
							localStorage.setItem('isLoggedIn', '1');
							setIsLoggedIn(true);
						  };

						  return (
							<AuthContext.Provider
							  value={{
								isLoggedIn: isLoggedIn,
								onLogout: logoutHandler,
								onLogin: loginHandler,
							  }}
							>
							  {props.children}
							</AuthContext.Provider>
						  );
						};

						export default AuthContext;
						
						
						in the App.js file :
						
						import React, { useContext } from 'react';

						import Login from './components/Login/Login';
						import Home from './components/Home/Home';
						import MainHeader from './components/MainHeader/MainHeader';
						import AuthContext from './store/auth-context';

						function App() {
						  const ctx = useContext(AuthContext);

						  return (
							<React.Fragment>
							  <MainHeader />
							  <main>
								{!ctx.isLoggedIn && <Login />}
								{ctx.isLoggedIn && <Home />}
							  </main>
							</React.Fragment>
						  );
						}

						export default App;
						
						
						in index.js file :
						
						import React from 'react';
						import ReactDOM from 'react-dom/client';

						import './index.css';
						import App from './App';
						import { AuthContextProvider } from './store/auth-context';

						const root = ReactDOM.createRoot(document.getElementById('root'));
						root.render(
						  <AuthContextProvider>
							<App />
						  </AuthContextProvider>
						);
						

************************************A look behind the scenes of React & optimization techniques**************************************
****************************************************************************************************************** 

		--> React is a JS library for building UI. React uses components to build UI. React doesn't care about the Real DOM. It only cares about the Components, their data (i.e. state,
			props and context). Whenever the state/context/props of a component changes, the React re-evaluates the Component, but that doesn't means that real DOM is changed/ re-rendered.
			React determines how the component tree currently looks like and what it should look like.
		
		--> ReactDOM is an interface to the web. It manipulates the Real DOM.
			ReactDOm receives the differences and then manipulates the real DOM. This is Virtual DOM diffing.
			
		--> Re-evaluates all the child components, whenever the parent component is re-evaluated. This is not very optimised. So, if we want this child component to be re-evaluated
			only in case the props sent by the parent are changed, we can wrap our child component in React.memo().
			
			ex :
			import React from 'react';
			
			const ChildComponent = (props) => {
				return ...... ;
			}
			
			export default React.memo(ChildComponent);
			
		--> useCallback hook : 
		
			import React, {useState, useCallback} from 'react';
			..
			..
			..
			
			
			
			function App() {
				const [showParagraph, setShowParagraph] = useState(false);
				
				Approach 1:
				const toggleParagraphHandler = () => {
					setShowParagraph((prevShowParagrapg) => !prevShowParagraph);
				};
				
				Approach 2:
				const toggleParagraphHandler = useCallback(() => {
					setShowParagraph((prevShowParagrapg) => !prevShowParagraph);
				},[]);
				
				return <div .....
					......
					.....
					..
					<Button onClick={toggleParagraphHandler}> Toggle Paragraph! </Button>
				
			}
			
			export default App;
			
			
			In Button.js file :
			
			import React from 'react';
			
			const Button = (props) => {
				return ...... ;
			}
			
			export default React.memo(Button);
			
			
			
			
			**** Only in the approach 2, the react-memo will work as expected.
			
			
			Just like, useCallback for remembering the functions, we can use "useMemo" hook to remember data.
			
			
			import React, {usememo} from 'react';
			
			const DemoList = (props) => {
				const {items} = props;
				const sortedList = useMemo(
				() => {
					return items.sort((a,b) => a - b);
				}, [items]
				); // using "useMemo()" hook ensures that sortedList in our component is not evaluated everytime this component is re-evaluated by the react.
				// Instead, its called only when items prop is changed.
				
				return (....);
			}
			
			export default React.memo(DemoList);


************************************An alternative way of building components : class based components **************************************
****************************************************************************************************************** 

		--> In most modern/new React projects, you won't see class-based components. But many traditional applications use these.
			Also to build error boundaries, we still need these components.
			
			class Product extends Component {
				render() {
					return <h2> A product!</h2>
				}
			}
			
			Traditionally (React < 16.8), you had to use class-based components to manage "State". But, React 16.8 introduced hooks for functional components.
			Class-based components can't use hooks.
			
			const User = (props) => {
				return <li className={classes.user}>{props.name}</li>;
			}
			
						||
						||
						||
						\/
			import {Component} from 'react';
			
			class User extends Component {
				render() {
					return <li className={classes.user}>{this.props.name}</li>;
				}
			}
			
			
			
			
			class Users extends Component {
			
			constructor() {
				super();
				this.state = {
						showUsers: true
				};
			}
			
			toggleUsershandler() {
				this.setState((currState) => {
						return {showUsers: !currState.showUsers};
				});
				
			}
				render() {
				const usersList = (
				<ul>.......</ul>
				);
					return (
						<div className={classes.users}>
							<button onClick={this.toggleUsershandler.bind(this)}>
							{this.state.showUsers ? 'Hide' : 'Show'} Users
							</button>
							{this.state.showUsers && usersList}
						</div>
					)
				}
			}
			
			
		--> components lifecycle : 
			ex: componentDidMount() : once component was evaluated and rendered : equivalent to useEffect(...,[])
				componentDidupdate() : once component was re-evaluated and re-rendered
				componentWillUnmount() : right before component is removed from the DOM : useEffect(() => {..... return () => {..}}, [])
																						  so basically like the clean-up function of use effect.
		
		--> Error Boundaries : 
								We can handle the errors in the components itself, using try and catch. But if we want to handle it outside the 
								component, then we can use Error Boundary.
								
								class ErrorBoundary extends Component {
									constructor() {
										super();
										this.state = {hasError: false};
									}
								
									componentDidCatch(error) {
										// this method gets triggerd, whenever a child component throws an error.
										this.setState({hasError: true});
									}
									
									render() {
									if(this.state.hasError) {
										return <p>Something ewnt wrong!</p>
									}
										return this.props.children;
									}
								}
			
			
			
			
			
			
			
		
							
							