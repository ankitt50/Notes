************************************REACT*******************************************************************
************************************************************************************************************


************************************REACT BASICS AND WORKING WITH COMPONENTS**************************************
******************************************************************************************************************


React - It is a JS library to build User Interfaces
		It is all about components.Bcoz, all UIs are in the end made up of components.
		
		Components : Reusability, and Separation of concerns.
		
		--> to create and start react app :
		
			npm install -g create-react-app
			npx create-react-app my-app
			cd my-app
			npm start
			
			npm install command is used to reinstall/install all the dependencies.
			These downloaded/installed dependenies can be seen in the node_module folder.
			
			index.js file is the first file to be executed.
			index.html file contains the "root" element of the react-app.
			
			JSX : HTML code inside javascript code. 
			
			Declarative approach is used for React components. We just define the state of elements and let the React 
			figure out the actual JS DOM instructions.
			The other approach is called "Imperative" approach. This is used in plain vanilla JS. We have to give clear step by step instructions
			regarding the DOM manipulation.
			
			Component in React is a JavaScript function. This function's return statement must have only one root element.
			
		--> We can use "props" for passing data to any component.
			
			** Inside {} we can write any JS code.
			** We can name the parameter anything, but as a convention, we use "props" as a name.
			
			
			function ExpenseItem(props) {
				return {
					<div ..... >
					<div>{props.title}</div>
					....
					....
					....
					</div>
				}
			}
			
			
			<ExpenseItem 
			title = {expenses[0].title}
			></ExpenseItem>
			
			** there is a special prop called "children". Don't define it like an attribute, but have to wrap it inside the component.
			
			function Card(props) {
			return {
			<div className="Card">{props.children}</div>
			}
			}
			
			<Card>
			<div>.......</div>
			....
			....
			...
			</Card>
			
		--> JSX 
			
			Under the hood :
			
				React.createElement(
				'div',
				{},
				React.createElement(
				'h2',
				{},"Let's get started"),
				React.createElement(
				'Expense',
				{items: expenses}
				)
				);
			
			JSX Code that we write :
			
				<div>
					<h2>Let's get started</h2>
					<Expense items={expenses}/>
				</div>
				

************************************REACT STATE AND WORKING WITH EVENTS**************************************
******************************************************************************************************************

		--> Adding event listener to a button :
			
			<button onclick={() => {Console.log('Clicked!')}}></button>
			
			<button onclick={clickHandler}>Click me</button>
			
			const clickHandler =() => {
				Console.log('Clicked');
			};
		
		--> "State" in React :
		
				import React, {useState} from 'react'; //useState is a react hook. It is called directly inside the react component function.
				
				const [title, setTitle] = useState('defaultTitle');
				// the default Title value provided is used only the first time the component is rendered.
				// When the component is re-rendered after the setTitle method call, the title value provided is 
				// the new updated value, which can be used inside the component.
				
				const clickHandler = () => {
					setTitle("UpdatedTitle"); // setTitle don't just change the value of title variable. It is a special function to 
											  // also render the component again with the new updated title value
											  // Also the value of the variable is not changed right away, but is scheduled to be
											  // changed.
					// state is managed on per component instance basis. So, changes in one of the instance of a component
					// will not be reflected on other instances of that same component.
					// Also state used to manage any one variable of a component will not affect state used for any other
					// variable of that same component.
				};
				
				return (
				..
				..
				..
				<h2>{title}</h2>
				..
				..
				..
				);
				
		--> working with forms :
		
				const [enteredTitle, setEnteredTitle] = setState('');
				
				
				
				titleChangeHandler = (event) => {
					Console.log(event.target.value);
					setEnteredTitle(event.target.value);
					// to save the entered title in a variable,
					// which can be used later, when user submits the form.
				};
				
				
				const formSubmitHandler = (event) => {
					event.preventDefault(); // to prevent submission of page to the server and reloading of the page.
					..
					..
					..
					..
				};
				
				<form onSubmit={formSubmitHandler}>
					<div className="..">
						<label>Title</label>
						<input type="text" value={enteredTitle} onChange={titleChangeHandler}/>
					</div>
					<div className="..">
						<label>Amount</label>
						<input type="number" min="" step="" />
					</div>
					<div className="..">
						<label>Date</label>
						<input type="date" min="" max="" />
					</div>
					<div>
						<button type="Submit">Submit</button>
					</div>
				</form>
				
				** Adding "enteredTitle" as value in the text field, which we are getting useState, leads to two way binding.
				
				** to pass data from child to parent component, we can pass a function as a prop from parent to child. This
				function can be called from child whenever we need.
				
				** Lifting state up : If we have to pass data between components that don't have parent-child relation, then we have to
				   first pass data from child to parent (i.e lifting up) and then parent to the component to which we have to finally 
				   pass the data to.
				   
				** Controlled Component : Whenever there is a two-way binding between child and parent component, then child component is called
										  Controlled component. In two way binding, the child component passes the data (on Change only) 
										  to the parent through a method, and parent passes the same data/variable as a prop to the child.
				
				
				
************************************RENDERING LISTS AND CONDITIONAL CONTENT**************************************
******************************************************************************************************************

		--> Rendering a list of data :
				
				{props.events.map(event => <ExpenseItem key={expense.id} title={expense.title} ...... />)}
				
				** always add "key" when rendering a list.
				
		--> Outputting Conditional components :
		
			{filteredExpenses.length === 0 ? (<p>No content to display</p>) : 
			(
				filteredExpenses.map(expense => <ExpenseItem key= {} ....... />)
			)
			}
				
				
				(or)
				
			{filteredExpenses.length === 0  && (<p>No content to display</p>) }
			{filteredExpenses.length > 0  && (
				filteredExpenses.map(expense => <ExpenseItem key= {} ....... />)
			)}
			
			 (or)
			 
			 const expenseContent = <p>No content to display</p> ;
			 
			 if(filteredExpenses.length > 0) {
				expenseContent = filteredExpenses.map(expense => <ExpenseItem key= {} ....... /> ;
			 }
			 
			 return (
			 ..
			 ..
			 ..
			 {expenseContent}
			 ..
			 .
			 .
			 );


************************************STYLING REACT COMPONENTS**************************************
****************************************************************************************************************** 
			 
		--> Dynamic Inline Style
				
				ex: <label style={{color: !isValid ? 'red' : 'black'}}> Some Label Text </label>
			
					<input style={
					{
						borderColor : !isValid ? 'red' : 'black',
						background: !isValid > 'Salmon' : 'transparent'
					}
					}
					type="text" onChange={someHandler} />
			 
		--> Dynamically setting CSS classes
		
				<div className={`form-input ${!isValid ? 'invalid' : ''}`} >
					....
				</div>
				
				
				in CSS file :
					
					.form-control.invalid label {
						color: 'red'
					}
					
					.form-control.invalid input {
						borderColor: 'red',
						background: 'Salmon'
					}
					
		--> Styled Components 
				
				npm install --save styled-components
				
				** used to prevent spill overs i.e. no other component should be affected, if by mistake we have used multiple
					components with the same class name. styled-component package provides a unique class name for all the components
					which have used it for styling.
					
				** We can also pass props to the styled component methods for dynamic styling.
				
		    ** We can also achive the same using "CSS modules" in react.
			
************************************Diving Deeper: working with Fragments, Portals and "Refs"**************************************
****************************************************************************************************************** 
	
		--> JSX limitations : can't have more than one element adjacent to another when returning them from a component.
							  
							  We generally use a wrapping "div" at top level. 
							  We can also wrap these adjacent elements inside an array. But always add "key" attribute for each of these elements.
							  But with these wrapping "div", we have a new problem called "<div> Soup".
							  This means there are all these wrapping elements which are now being rendered, but don't have any usage.
							  
							  We can also create a custom component, which just returns the childrens and nothing else.
							  Then this component can be used to wrap the adjacent components/elements.
							  
							  function Wrapper(props) {
								
								return props.children;
								
							  }
							  
							  
			React Fragments : provided by react to wrap around adjacent elements.
							
							<React.Fragment>
								<h2>.....</h2>
								<p>.....</p>
							</React.Fragment>
							  
							  
							  (or)
							  
							<>
								<h2>.....</h2>
								<p>.....</p>
							</>
							
			
			React Portals :
							
							If we are creating a "Modal" component/ Side Menu Component/ or any overlay component. Its not a good practice to
							write/render (in final DOM) the component side-by-side other Components. It although works fine, but is not a good practice.
							
							
							create new div elements in the index.html :						
							
							<body>
								...
								....
								<div id="backdrop-root"></div>
								<div id="overlay-root"></div>
								<div id="root"></div>
							</body>
							
							
							
							inside the ErrorModal component return : 
							
							<React.Fragment>
							{ 
							
							ReactDOM.createPortal(
								<Backdrop onConfirm={props.onConfirm} />, // This is your custom modal component
								document.getElementById('backdrop-root')
							)
							
							}
							>/React.Fragment>
							
			
			"Refs" :    import {useState, useRef} from 'react';
						
						It is another hook provided by react library.
						
						const nameInputRef = useRef();
						
						
						<input
							id="username"
							type="text"
							value={enteredUsername}
							onChange={usernameChangeHandler} --> this will not be required, once we use "ref"
							ref = {nameInputRef}
							
						/>
						
						
						
						cont submitBtnHandler = (event) => {
						
						event.preventDefault;
						....
						....
						...
						console.log(nameInputRef.current.value);
						}
						
						
						** Using refs instead of useState hooks, gives us direct access to the real DOM, and we are not using 
						react to manipulate or read from the element.
						Also, the input elements now becomes uncontrolled.
						
						** It is generally not a good practice to work with real DOM element directly to manipulate them.
						Although reading from them isn't a big issue.
			
							
			


	
			
