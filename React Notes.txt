************************************REACT*******************************************************************
************************************************************************************************************


************************************REACT BASICS AND WORKING WITH COMPONENTS**************************************
******************************************************************************************************************


React - It is a JS library to build User Interfaces
		It is all about components.Bcoz, all UIs are in the end made up of components.
		
		Components : Reusability, and Separation of concerns.
		
		--> to create and start react app :
		
			npm install -g create-react-app
			npx create-react-app my-app
			cd my-app
			npm start
			
			npm install command is used to reinstall/install all the dependencies.
			These downloaded/installed dependenies can be seen in the node_module folder.
			
			index.js file is the first file to be executed.
			index.html file contains the "root" element of the react-app.
			
			JSX : HTML code inside javascript code. 
			
			Declarative approach is used for React components. We just define the state of elements and let the React 
			figure out the actual JS DOM instructions.
			The other approach is called "Imperative" approach. This is used in plain vanilla JS. We have to give clear step by step instructions
			regarding the DOM manipulation.
			
			Component in React is a JavaScript function. This function's return statement must have only one root element.
			
		--> We can use "props" for passing data to any component.
			
			** Inside {} we can write any JS code.
			** We can name the parameter anything, but as a convention, we use "props" as a name.
			
			
			function ExpenseItem(props) {
				return {
					<div ..... >
					<div>{props.title}</div>
					....
					....
					....
					</div>
				}
			}
			
			
			<ExpenseItem 
			title = {expenses[0].title}
			></ExpenseItem>
			
			** there is a special prop called "children". Don't define it like an attribute, but have to wrap it inside the component.
			
			function Card(props) {
			return {
			<div className="Card">{props.children}</div>
			}
			}
			
			<Card>
			<div>.......</div>
			....
			....
			...
			</Card>
			
		--> JSX 
			
			Under the hood :
			
				React.createElement(
				'div',
				{},
				React.createElement(
				'h2',
				{},"Let's get started"),
				React.createElement(
				'Expense',
				{items: expenses}
				)
				);
			
			JSX Code that we write :
			
				<div>
					<h2>Let's get started</h2>
					<Expense items={expenses}/>
				</div>
				

************************************REACT STATE AND WORKING WITH EVENTS**************************************
******************************************************************************************************************

		--> Adding event listener to a button :
			
			<button onclick={() => {Console.log('Clicked!')}}></button>
			
			<button onclick={clickHandler}>Click me</button>
			
			const clickHandler =() => {
				Console.log('Clicked');
			};
		
		--> "State" in React :
		
				import React, {useState} from 'react'; //useState is a react hook. It is called directly inside the react component function.
				
				const [title, setTitle] = useState('defaultTitle');
				// the default Title value provided is used only the first time the component is rendered.
				// When the component is re-rendered after the setTitle method call, the title value provided is 
				// the new updated value, which can be used inside the component.
				
				const clickHandler = () => {
					setTitle("UpdatedTitle"); // setTitle don't just change the value of title variable. It is a special function to 
											  // also render the component again with the new updated title value
											  // Also the value of the variable is not changed right away, but is scheduled to be
											  // changed.
					// state is managed on per component instance basis. So, changes in one of the instance of a component
					// will not be reflected on other instances of that same component.
					// Also state used to manage any one variable of a component will not affect state used for any other
					// variable of that same component.
				};
				
				return (
				..
				..
				..
				<h2>{title}</h2>
				..
				..
				..
				);
				
		--> working with forms :
		
				const [enteredTitle, setEnteredTitle] = setState('');
				
				
				
				titleChangeHandler = (event) => {
					Console.log(event.target.value);
					setEnteredTitle(event.target.value);
					// to save the entered title in a variable,
					// which can be used later, when user submits the form.
				};
				
				
				const formSubmitHandler = (event) => {
					event.preventDefault(); // to prevent submission of page to the server and reloading of the page.
					..
					..
					..
					..
				};
				
				<form onSubmit={formSubmitHandler}>
					<div className="..">
						<label>Title</label>
						<input type="text" value={enteredTitle} onChange={titleChangeHandler}/>
					</div>
					<div className="..">
						<label>Amount</label>
						<input type="number" min="" step="" />
					</div>
					<div className="..">
						<label>Date</label>
						<input type="date" min="" max="" />
					</div>
					<div>
						<button type="Submit">Submit</button>
					</div>
				</form>
				
				** Adding "enteredTitle" as value in the text field, which we are getting useState, leads to two way binding.
				
				** to pass data from child to parent component, we can pass a function as a prop from parent to child. This
				function can be called from child whenever we need.
				
				** Lifting state up : If we have to pass data between components that don't have parent-child relation, then we have to
				   first pass data from child to parent (i.e lifting up) and then parent to the component to which we have to finally 
				   pass the data to.
				   
				** Controlled Component : Whenever there is a two-way binding between child and parent component, then child component is called
										  Controlled component. In two way binding, the child component passes the data (on Change only) 
										  to the parent through a method, and parent passes the same data/variable as a prop to the child.
				
				
				
************************************RENDERING LISTS AND CONDITIONAL CONTENT**************************************
******************************************************************************************************************

		--> Rendering a list of data :
				
				{props.events.map(event => <ExpenseItem key={expense.id} title={expense.title} ...... />)}
				
				** always add "key" when rendering a list.
				
		--> Outputting Conditional components :
		
			{filteredExpenses.length === 0 ? (<p>No content to display</p>) : 
			(
				filteredExpenses.map(expense => <ExpenseItem key= {} ....... />)
			)
			}
				
				
				(or)
				
			{filteredExpenses.length === 0  && (<p>No content to display</p>) }
			{filteredExpenses.length > 0  && (
				filteredExpenses.map(expense => <ExpenseItem key= {} ....... />)
			)}
			
			 (or)
			 
			 const expenseContent = <p>No content to display</p> ;
			 
			 if(filteredExpenses.length > 0) {
				expenseContent = filteredExpenses.map(expense => <ExpenseItem key= {} ....... /> ;
			 }
			 
			 return (
			 ..
			 ..
			 ..
			 {expenseContent}
			 ..
			 .
			 .
			 );


************************************STYLING REACT COMPONENTS**************************************
****************************************************************************************************************** 
			 
		--> Dynamic Inline Style
				
				ex: <label style={{color: !isValid ? 'red' : 'black'}}> Some Label Text </label>
			
					<input style={
					{
						borderColor : !isValid ? 'red' : 'black',
						background: !isValid > 'Salmon' : 'transparent'
					}
					}
					type="text" onChange={someHandler} />
			 
		--> Dynamically setting CSS classes
		
				<div className={`form-input ${!isValid ? 'invalid' : ''}`} >
					....
				</div>
				
				
				in CSS file :
					
					.form-control.invalid label {
						color: 'red'
					}
					
					.form-control.invalid input {
						borderColor: 'red',
						background: 'Salmon'
					}
					
		--> Styled Components 
				
				npm install --save styled-components
				
				** used to prevent spill overs i.e. no other component should be affected, if by mistake we have used multiple
					components with the same class name. styled-component package provides a unique class name for all the components
					which have used it for styling.
					
				** We can also pass props to the styled component methods for dynamic styling.
				
		    ** We can also achive the same using "CSS modules" in react.
			
************************************Diving Deeper: working with Fragments, Portals and "Refs"**************************************
****************************************************************************************************************** 
	
		--> JSX limitations : can't have more than one element adjacent to another when returning them from a component.
							  
							  We generally use a wrapping "div" at top level. 
							  We can also wrap these adjacent elements inside an array. But always add "key" attribute for each of these elements.
							  But with these wrapping "div", we have a new problem called "<div> Soup".
							  This means there are all these wrapping elements which are now being rendered, but don't have any usage.
							  
							  We can also create a custom component, which just returns the childrens and nothing else.
							  Then this component can be used to wrap the adjacent components/elements.
							  
							  function Wrapper(props) {
								
								return props.children;
								
							  }
							  
							  
			React Fragments : provided by react to wrap around adjacent elements.
							
							<React.Fragment>
								<h2>.....</h2>
								<p>.....</p>
							</React.Fragment>
							  
							  
							  (or)
							  
							<>
								<h2>.....</h2>
								<p>.....</p>
							</>
							
			
			React Portals :
							
							If we are creating a "Modal" component/ Side Menu Component/ or any overlay component. Its not a good practice to
							write/render (in final DOM) the component side-by-side other Components. It although works fine, but is not a good practice.
							
							
							create new div elements in the index.html :						
							
							<body>
								...
								....
								<div id="backdrop-root"></div>
								<div id="overlay-root"></div>
								<div id="root"></div>
							</body>
							
							
							
							inside the ErrorModal component return : 
							
							<React.Fragment>
							{ 
							
							ReactDOM.createPortal(
								<Backdrop onConfirm={props.onConfirm} />, // This is your custom modal component
								document.getElementById('backdrop-root')
							)
							
							}
							>/React.Fragment>
							
			
			"Refs" :    import {useState, useRef} from 'react';
						
						It is another hook provided by react library.
						
						const nameInputRef = useRef();
						
						
						<input
							id="username"
							type="text"
							value={enteredUsername}
							onChange={usernameChangeHandler} --> this will not be required, once we use "ref"
							ref = {nameInputRef}
							
						/>
						
						
						
						cont submitBtnHandler = (event) => {
						
						event.preventDefault;
						....
						....
						...
						console.log(nameInputRef.current.value);
						}
						
						
						** Using refs instead of useState hooks, gives us direct access to the real DOM, and we are not using 
						react to manipulate or read from the element.
						Also, the input elements now becomes uncontrolled.
						
						** It is generally not a good practice to work with real DOM element directly to manipulate them.
						Although reading from them isn't a big issue.
			
							
************************************Advanced: Handling Side effects, using reducers and using the context API**************************************
****************************************************************************************************************** 

		--> Effect (or "Side Effect") : main job of react application is to render UI and react to User Input.
										Anything else, which is not concerned with UI rendering/re-rendering is "Side Effect"
										ex: Store data, send Http requests, timers, etc.
										These tasks must happen outside of the normal component evaluation. As they might delay the rendering.
										
										So,for this we can use "useEffect()" hook of the react.
													
			
									localStorage.setItem('isLoggedIn','1');
									localStorage.removeItem('isLoggedIn');
									
									const storedUserLoggedInInformation = localStorage.getItem('isLoggedIn');
									
									if (storedUserLoggedInInformation === '1') {
										setIsLoggedIn(true); // Using useState  will create a infinite loop.
															// everytime we call setIsLoggedIn, the component will be re-rendered and the 
															// if loop will again be executed and again the setIsLoggedIn function will
															// be called.
									}
									
									we can wrap this inside the "useEffect" hook, if we want it to run/execute just once.
									
									useEffect(
										() => {
										
										
										const storedUserLoggedInInformation = localStorage.getItem('isLoggedIn');
									
										if (storedUserLoggedInInformation === '1') {
										setIsLoggedIn(true); 
										}
										
											`
										}, []);
										
									
									useEffect can also be used to execute only if a dependency is changes.
									
									useEffect(
										() => {
										setFormIsvalid(enteredEmail.includes('@') && eneteredPassword.trim().length > 6);`
										}, [enteredEmail, eneteredPassword]);
										
									
									** don't add state updating functions as dependencies inside the useEffect.
									** don't add "built-in" APIs or functions.
									** don't add variables/functions defined outside of your component. Such functions/variables are not
									   created inside of a component function and hence changing them won't affect your components.
									  
									** In short, add anything that could change because your component re-rendered.
						
	
			
								** useEffect cleanup -> for example we want to check if the user entered email is valid or not. Then we don't have to check it after every keystroke.
														Or if we want to check if the entered username already exists or not in the DB? We should not ideally be sending request to the server after 
														every keystroke. Instead, it would be better if we check the user input after the user has stopped typing for some seconds.
														This is called de-bounsing.
														With useEffect, it is very easy to implement.
														
														ex : 
														
														useEffect(
														
														() => {
														
															const identifier = setTimeout(()=> {
																console.log('Checking for validity');
																setFormIsValid()
															}, 500);
														
														
														// cleanup function : It is executed before the use effect will be executed again next time.
														// So, it run before the useEffect function everytime, except for the very first time.
														return () => {
															clearTimeout(identifier);
														}
														},[enteredEmail,eneteredPassword]);
														
		
		
		--> useReducer() for state management : It can be used when the state management for any variable is more complex and useState() becomes more error prone.
		
												import React, {useState, useEffect, useReducer} from 'react';
												
												const[state, dispatchFn] = useReducer(reducerFn, initialState, initFn);
												
												
												// this function is defined outside the component
												const emailReducer = (state,action) => {
													if(action.type === 'USER_INPUT') {
													// action represents the new user entered values.
														return {value: action.val, isValid: action.val.includes('@')}; 
													}
													if(action.type === 'INPUT_BLUR') {
													// state represents the current state, and is guaranteed to be the latest by react.
														return {value: state.value, isValid: state.value.includes('@')}; 
													}
													return {value: '', isValid: false};
												};
												
												const Login = (props) => {
													
													const[emailState, dispatchEmail] = useReducer(emailReducer, {value: '', isValid: false});
													
													
													...
													...
													...
													
													const emailChangeHandler = (event) => {
														dispatchEmail({type: 'USER_INPUT', val: event.target.value});
														...
														...
														...
													}
													
													const passwordChangeHandler = (event) => {
														setEnteredPassword(event.target.value);
														setFormIsValid(
															emailState.value.includes('@') && event.target.value.trim().length > 6
															
															(or)
															
															emailState.isValid && event.target.value.trim().length > 6
														);
													}
													
													const validateEmailHandler = () => {
														dispatchEmail({type:'INPUT_BLUR'});
													}
													
													const {isValid: emailIsValid } = emailState; // destructuring the object and giving it an alias "emailIsValid"
													const{isValid: passwordIsValid} = passwordState;
													
													useEffect(
														() => {
															const identifier = setTimeout(() => {
																setFormIsValid(emailIsValid && passwordIsValid);
															},500);
															
															return () => {
																clearTimeout(identifier);
															}
														}, [emailIsValid,passwordIsValid ]
													);
													
												
												}
		
		
		--> React Context APi : component-wide, "behind-the-scenes" state storage.
								It helps in cases where we have to pass data from one component to too many components.
								
								In "auth-context.js" file :
								
								import React from 'react';
								
								const AuthContext = React.createContext(
								{
									isLoggedIn: false
								}
								);
								
								export default AuthContext;
								
								
								In "App.js" file :
								
								import AuthContext from 'auth-context';
								
								
								retun (
								<React.Fragment>
								<AuthContext.Provider
									value={
										{
											isLoggedIn: isLoggedIn
										}
									}
								>
									<MainHeader .......... />
									<main>
										{ !isLoggedIn && <Login ......./> }
										{ isLoggedIn && <Home ......./> }
									</main>
								<AuthContext.Provider>
								</React.Fragment>
								)
								
								
								In "Navigation.js" file :
								
								const Navigation = (props) => {
									<AuthContext.Consumer>
									{
										(ctx) => {
											return (
												<nav .....>
												<ul>
													{ctx.isLoggedIn && (
														<li> <a href="/">Users</a>
													)}
												..
												...
												...
												..
												</nav>
											)
										}
									}
										
									</AuthContext.Consumer>
								}
								
								
								Alternative way is using "useContext()" hook, instead of the AuthContext.Consumer
								
								const Navigation = (props) => {
								
								const ctx = useContext(AuthContext);
									
											return (
												<nav .....>
												<ul>
													{ctx.isLoggedIn && (
														<li> <a href="/">Users</a>
													)}
												..
												...
												...
												..
												</nav>
											)
										
								}
								
				
				Alternate to using the AppContext.Provider in the App.js file is to create a custom context provider :
				
				
						in the "auth-context.js" file :
						
						import React, { useState, useEffect } from 'react';

						const AuthContext = React.createContext({
						  isLoggedIn: false,
						  onLogout: () => {},
						  onLogin: (email, password) => {}
						});

						export const AuthContextProvider = (props) => {
						  const [isLoggedIn, setIsLoggedIn] = useState(false);

						  useEffect(() => {
							const storedUserLoggedInInformation = localStorage.getItem('isLoggedIn');

							if (storedUserLoggedInInformation === '1') {
							  setIsLoggedIn(true);
							}
						  }, []);

						  const logoutHandler = () => {
							localStorage.removeItem('isLoggedIn');
							setIsLoggedIn(false);
						  };

						  const loginHandler = () => {
							localStorage.setItem('isLoggedIn', '1');
							setIsLoggedIn(true);
						  };

						  return (
							<AuthContext.Provider
							  value={{
								isLoggedIn: isLoggedIn,
								onLogout: logoutHandler,
								onLogin: loginHandler,
							  }}
							>
							  {props.children}
							</AuthContext.Provider>
						  );
						};

						export default AuthContext;
						
						
						in the App.js file :
						
						import React, { useContext } from 'react';

						import Login from './components/Login/Login';
						import Home from './components/Home/Home';
						import MainHeader from './components/MainHeader/MainHeader';
						import AuthContext from './store/auth-context';

						function App() {
						  const ctx = useContext(AuthContext);

						  return (
							<React.Fragment>
							  <MainHeader />
							  <main>
								{!ctx.isLoggedIn && <Login />}
								{ctx.isLoggedIn && <Home />}
							  </main>
							</React.Fragment>
						  );
						}

						export default App;
						
						
						in index.js file :
						
						import React from 'react';
						import ReactDOM from 'react-dom/client';

						import './index.css';
						import App from './App';
						import { AuthContextProvider } from './store/auth-context';

						const root = ReactDOM.createRoot(document.getElementById('root'));
						root.render(
						  <AuthContextProvider>
							<App />
						  </AuthContextProvider>
						);
						

************************************A look behind the scenes of React & optimization techniques**************************************
****************************************************************************************************************** 

		--> React is a JS library for building UI. React uses components to build UI. React doesn't care about the Real DOM. It only cares about the Components, their data (i.e. state,
			props and context). Whenever the state/context/props of a component changes, the React re-evaluates the Component, but that doesn't means that real DOM is changed/ re-rendered.
			React determines how the component tree currently looks like and what it should look like.
		
		--> ReactDOM is an interface to the web. It manipulates the Real DOM.
			ReactDOm receives the differences and then manipulates the real DOM. This is Virtual DOM diffing.
			
		--> Re-evaluates all the child components, whenever the parent component is re-evaluated. This is not very optimised. So, if we want this child component to be re-evaluated
			only in case the props sent by the parent are changed, we can wrap our child component in React.memo().
			
			ex :
			import React from 'react';
			
			const ChildComponent = (props) => {
				return ...... ;
			}
			
			export default React.memo(ChildComponent);
			
		--> useCallback hook : 
		
			import React, {useState, useCallback} from 'react';
			..
			..
			..
			
			
			
			function App() {
				const [showParagraph, setShowParagraph] = useState(false);
				
				Approach 1:
				const toggleParagraphHandler = () => {
					setShowParagraph((prevShowParagrapg) => !prevShowParagraph);
				};
				
				Approach 2:
				const toggleParagraphHandler = useCallback(() => {
					setShowParagraph((prevShowParagrapg) => !prevShowParagraph);
				},[]);
				
				return <div .....
					......
					.....
					..
					<Button onClick={toggleParagraphHandler}> Toggle Paragraph! </Button>
				
			}
			
			export default App;
			
			
			In Button.js file :
			
			import React from 'react';
			
			const Button = (props) => {
				return ...... ;
			}
			
			export default React.memo(Button);
			
			
			
			
			**** Only in the approach 2, the react-memo will work as expected.
			
			
			Just like, useCallback for remembering the functions, we can use "useMemo" hook to remember data.
			
			
			import React, {usememo} from 'react';
			
			const DemoList = (props) => {
				const {items} = props;
				const sortedList = useMemo(
				() => {
					return items.sort((a,b) => a - b);
				}, [items]
				); // using "useMemo()" hook ensures that sortedList in our component is not evaluated everytime this component is re-evaluated by the react.
				// Instead, its called only when items prop is changed.
				
				return (....);
			}
			
			export default React.memo(DemoList);


************************************An alternative way of building components : class based components **************************************
****************************************************************************************************************** 

		--> In most modern/new React projects, you won't see class-based components. But many traditional applications use these.
			Also to build error boundaries, we still need these components.
			
			class Product extends Component {
				render() {
					return <h2> A product!</h2>
				}
			}
			
			Traditionally (React < 16.8), you had to use class-based components to manage "State". But, React 16.8 introduced hooks for functional components.
			Class-based components can't use hooks.
			
			const User = (props) => {
				return <li className={classes.user}>{props.name}</li>;
			}
			
						||
						||
						||
						\/
			import {Component} from 'react';
			
			class User extends Component {
				render() {
					return <li className={classes.user}>{this.props.name}</li>;
				}
			}
			
			
			
			
			class Users extends Component {
			
			constructor() {
				super();
				this.state = {
						showUsers: true
				};
			}
			
			toggleUsershandler() {
				this.setState((currState) => {
						return {showUsers: !currState.showUsers};
				});
				
			}
				render() {
				const usersList = (
				<ul>.......</ul>
				);
					return (
						<div className={classes.users}>
							<button onClick={this.toggleUsershandler.bind(this)}>
							{this.state.showUsers ? 'Hide' : 'Show'} Users
							</button>
							{this.state.showUsers && usersList}
						</div>
					)
				}
			}
			
			
		--> components lifecycle : 
			ex: componentDidMount() : once component was evaluated and rendered : equivalent to useEffect(...,[])
				componentDidupdate() : once component was re-evaluated and re-rendered
				componentWillUnmount() : right before component is removed from the DOM : useEffect(() => {..... return () => {..}}, [])
																						  so basically like the clean-up function of use effect.
		
		--> Error Boundaries : 
								We can handle the errors in the components itself, using try and catch. But if we want to handle it outside the 
								component, then we can use Error Boundary.
								
								class ErrorBoundary extends Component {
									constructor() {
										super();
										this.state = {hasError: false};
									}
								
									componentDidCatch(error) {
										// this method gets triggerd, whenever a child component throws an error.
										this.setState({hasError: true});
									}
									
									render() {
									if(this.state.hasError) {
										return <p>Something ewnt wrong!</p>
									}
										return this.props.children;
									}
								}
	
	************************************Sending Http Requests **************************************
****************************************************************************************************************** 
			
		--> React App/ Browser-side Apps don't directly talk to DBs.
			
			** nowdays browsers have built in API to support Http requests. This Fetch API.
			
			function App() {
				function fetchMoviesHandler() {
					fetch('https://swapi.dev/api/films').then(
						response => {return response.json();}
					)then(
						data => {setMovies(data.results);}
					).catch();
				}
			}
			
			function App() {
				function fetchMoviesHandler() {
					const response = await fetch('https://swapi.dev/api/films');
					const data = await response.json();
					setMovies(data.results);
				}
			}
			
			
			function App() {
				function fetchMoviesHandler() {
				try{
					const response = await fetch('https://swapi.dev/api/films');
					
					
					if(response.ok) {
						// response also has a "status" field to hol concrete status code.
						// we can manually check that as well.
						const data = await response.json();
						setMovies(data.results);
						
					}
					else {
						throw new Error('Something went wrong');
					}
					
					
				}
				catch(error) {
					setError(error.message);
				}
				}
				
				
				useEffect(
						() => {
							fetchMoviesHandler();
						  }, []
					)
					
				
				function addMovieHandler(movie) {
					fetch('https://react-http-6b4a6.firebaseio.com/movies.json', {
						method : 'POST', 
						body: JSON.stringify(movie),
						headers: {
							'Content-Type': 'application/json'
						}
					});
					const data = await response.json();
					console.log(data);
				}
			}
			

	************************************Building Custom React Hooks **************************************
****************************************************************************************************************** 
			
		--> Custom Hooks : outsource stateful logic into re-usable functions.
						   React hooks must be called inside a React component function or a custom hook. It can't be 
						   called inside nested functions (i.e. functions defined inside the component function) or any blcok statements.
							
						   //Always start the name of custom hook with "use"
						   const useCounter = (forwards = true) => {
								const [counter, setCounter] = useState(0);
								useEffect(
								() => {
									const interval = setInterval(() => {
									if(forwards) {
										setCounter((prevCounter)=> prevCounter+1);
									}
									else {
										setCounter((prevCounter)=> prevCounter-1);
									}
									
									},1000);
									return () => clearInterval(interval);
								},[forwards]
								);
								return counter;
						   };
						   export default useCounter;
		
		--> building custom Http hook : 
						
						
						use-http.js file : 
						
						import { useState, useCallback } from 'react';

						const useHttp = () => {
						  const [isLoading, setIsLoading] = useState(false);
						  const [error, setError] = useState(null);

						  const sendRequest = useCallback(async (requestConfig, applyData) => {
							setIsLoading(true);
							setError(null);
							try {
							  const response = await fetch(requestConfig.url, {
								method: requestConfig.method ? requestConfig.method : 'GET',
								headers: requestConfig.headers ? requestConfig.headers : {},
								body: requestConfig.body ? JSON.stringify(requestConfig.body) : null,
							  });

							  if (!response.ok) {
								throw new Error('Request failed!');
							  }

							  const data = await response.json();
							  applyData(data);
							} catch (err) {
							  setError(err.message || 'Something went wrong!');
							}
							setIsLoading(false);
						  }, []);

						  return {
							isLoading,
							error,
							sendRequest,
						  };
						};

						export default useHttp;
				
				
						
						
						App.js file :
						
						import React, { useEffect, useState } from 'react';

						import Tasks from './components/Tasks/Tasks';
						import NewTask from './components/NewTask/NewTask';
						import useHttp from './hooks/use-http';

						function App() {
						  const [tasks, setTasks] = useState([]);

						  const { isLoading, error, sendRequest: fetchTasks } = useHttp();

						  useEffect(() => {
							const transformTasks = (tasksObj) => {
							  const loadedTasks = [];

							  for (const taskKey in tasksObj) {
								loadedTasks.push({ id: taskKey, text: tasksObj[taskKey].text });
							  }

							  setTasks(loadedTasks);
							};

							fetchTasks(
							  { url: 'https://react-http-6b4a6.firebaseio.com/tasks.json' },
							  transformTasks
							);
						  }, [fetchTasks]);

						  const taskAddHandler = (task) => {
							setTasks((prevTasks) => prevTasks.concat(task));
						  };

						  return (
							<React.Fragment>
							  <NewTask onAddTask={taskAddHandler} />
							  <Tasks
								items={tasks}
								loading={isLoading}
								error={error}
								onFetch={fetchTasks}
							  />
							</React.Fragment>
						  );
						}

						export default App;
			
			
	************************************Working with Forms and user Input **************************************
****************************************************************************************************************** 
		
		--> App.js file :
			
			import BasicForm from './components/BasicForm';

			function App() {
			  return (
				<div className="app">
				  <BasicForm />
				</div>
			  );
			}

			export default App;
			
		--> BasicForm.js file :
		
			import useInput from '../hooks/use-input';

			const isNotEmpty = (value) => value.trim() !== '';
			const isEmail = (value) => value.includes('@');

			const BasicForm = (props) => {
			
			// useInput is a custom Hook, created to handle input related states.
			// This way we can reuse the code for all user inputs.
			  const {
				value: firstNameValue,
				isValid: firstNameIsValid,
				hasError: firstNameHasError,
				valueChangeHandler: firstNameChangeHandler,
				inputBlurHandler: firstNameBlurHandler,
				reset: resetFirstName,
			  } = useInput(isNotEmpty);
			  const {
				value: lastNameValue,
				isValid: lastNameIsValid,
				hasError: lastNameHasError,
				valueChangeHandler: lastNameChangeHandler,
				inputBlurHandler: lastNameBlurHandler,
				reset: resetLastName,
			  } = useInput(isNotEmpty);
			  const {
				value: emailValue,
				isValid: emailIsValid,
				hasError: emailHasError,
				valueChangeHandler: emailChangeHandler,
				inputBlurHandler: emailBlurHandler,
				reset: resetEmail,
			  } = useInput(isEmail);

			  let formIsValid = false;

			  if (firstNameIsValid && lastNameIsValid && emailIsValid) {
				formIsValid = true;
			  }

			  const submitHandler = event => {
				event.preventDefault();

				if (!formIsValid) {
				  return;
				}

				console.log('Submitted!');
				console.log(firstNameValue, lastNameValue, emailValue);

				resetFirstName();
				resetLastName();
				resetEmail();
			  };

			  const firstNameClasses = firstNameHasError ? 'form-control invalid' : 'form-control';
			  const lastNameClasses = lastNameHasError ? 'form-control invalid' : 'form-control';
			  const emailClasses = emailHasError ? 'form-control invalid' : 'form-control';

			  return (
				<form onSubmit={submitHandler}>
				  <div className='control-group'>
					<div className={firstNameClasses}>
					  <label htmlFor='name'>First Name</label>
					  <input
						type='text'
						id='name'
						value={firstNameValue}
						onChange={firstNameChangeHandler}
						onBlur={firstNameBlurHandler}
					  />
					  {firstNameHasError && <p className="error-text">Please enter a first name.</p>}
					</div>
					<div className={lastNameClasses}>
					  <label htmlFor='name'>Last Name</label>
					  <input
						type='text'
						id='name'
						value={lastNameValue}
						onChange={lastNameChangeHandler}
						onBlur={lastNameBlurHandler}
					  />
					  {lastNameHasError && <p className="error-text">Please enter a last name.</p>}
					</div>
				  </div>
				  <div className={emailClasses}>
					<label htmlFor='name'>E-Mail Address</label>
					<input
					  type='text'
					  id='name'
					  value={emailValue}
					  onChange={emailChangeHandler}
					  onBlur={emailBlurHandler}
					/>
					{emailHasError && <p className="error-text">Please enter a valid email address.</p>}
				  </div>
				  <div className='form-actions'>
					<button disabled={!formIsValid}>Submit</button>
				  </div>
				</form>
			  );
			};

			export default BasicForm;
			
			
		--> use-input.js file 
		
			// Instead of useReducer, useState could also be used to manage input,blur and reset state.
			// But with useReducer, we can manage it in a single function.
			import { useReducer } from 'react';

			const initialInputState = {
			  value: '',
			  isTouched: false,
			};

			const inputStateReducer = (state, action) => {
			  if (action.type === 'INPUT') {
				// don't change the isTouched propety in the "INPUT"
				return { value: action.value, isTouched: state.isTouched };
			  }
			  if (action.type === 'BLUR') {
			  // don't change the value propety in the "BLUR"
				return { isTouched: true, value: state.value };
			  }
			  if (action.type === 'RESET') {
				return { isTouched: false, value: '' };
			  }
			  return inputStateReducer;
			};

			const useInput = (validateValue) => {
			  const [inputState, dispatch] = useReducer(
				inputStateReducer,
				initialInputState
			  );

			  const valueIsValid = validateValue(inputState.value);
			  const hasError = !valueIsValid && inputState.isTouched;

			  const valueChangeHandler = (event) => {
				dispatch({ type: 'INPUT', value: event.target.value });
			  };

			  const inputBlurHandler = (event) => {
				dispatch({ type: 'BLUR' });
			  };

			  const reset = () => {
				dispatch({ type: 'RESET' });
			  };

			  return {
				value: inputState.value,
				isValid: valueIsValid,
				hasError,
				valueChangeHandler,
				inputBlurHandler,
				reset,
			  };
			};

			export default useInput;
			
	************************************Diving into Redux (An alternative to the context API) **************************************
****************************************************************************************************************** 

		--> Redux : State management system for cross-component or app-wide state.
					Local state : which belongs to a single component. --> useState/useReducer
					Cross-Component state : effects multiple components. ex: open/closed state of modal overlay. --> props
					App-wide state : entire app is affected. ex: user authentication status. --> props
					
					** Both cross-component and app-wide state can be managed by useContext/redux.
					
					useContext disadvantages: complex setup/management in large enterprise level application; performance issues
					for high frequency updates.
					
					Redux is all about central data(state) store. Components can subscribe to the central data store.
					Components don't directly change the data. For this reducer functions are used.
					Components dispatch actions, which is then forwarded to reducer functions. Then reducer function change the data,
					based on the action.
					
					npm install redux
					
					npm install redux react-redux
					
					npm install @reduxjs/toolkit
					
					
					
					
					store --> index.js file :
					
					import { configureStore } from '@reduxjs/toolkit';

					import counterReducer from './counter';
					import authReducer from './auth';


					const store = configureStore({
					  reducer: { counter: counterReducer, auth: authReducer },
					});

					export default store;
					
					
					
					
					store --> auth.js file : 

					import { createSlice } from '@reduxjs/toolkit';

					const initialAuthState = {
					  isAuthenticated: false,
					};

					const authSlice = createSlice({
					  name: 'authentication',
					  initialState: initialAuthState,
					  reducers: {
						login(state) {
						  state.isAuthenticated = true;
						},
						logout(state) {
						  state.isAuthenticated = false;
						},
					  },
					});

					export const authActions = authSlice.actions;

					export default authSlice.reducer;
					
					
					
					
					store --> counter.js file :
					
					import { createSlice } from '@reduxjs/toolkit';

					const initialCounterState = { counter: 0, showCounter: true };

					const counterSlice = createSlice({
					  name: 'counter',
					  initialState: initialCounterState,
					  reducers: {
						increment(state) {
						  state.counter++; // It looks like we are directly making changes to the state object,
											// but this is not the case. Internally redux toolkit makes sure to not directly 
											// make changes to the state object.
						},
						decrement(state) {
						  state.counter--;
						},
						increase(state, action) {
						  state.counter = state.counter + action.payload;
						},
						toggleCounter(state) {
						  state.showCounter = !state.showCounter; 
						},
					  },
					});

					export const counterActions = counterSlice.actions;

					export default counterSlice.reducer;
					
					
					
					
					Just like useContext, we have to create a provider (index.js file) :
					
					import React from 'react';
					import ReactDOM from 'react-dom/client';
					import { Provider } from 'react-redux';

					import './index.css';
					import App from './App';
					import store from './store/index';

					const root = ReactDOM.createRoot(document.getElementById('root'));
					root.render(
					  <Provider store={store}>
						<App />
					  </Provider>
					);
					

					
					to use the redux store data in components :
					
					1) 
					import { useSelector } from 'react-redux';
					
					const isAuth = useSelector(state => state.auth.isAuthenticated);
					
					{!isAuth && <Auth />}
					{isAuth && <UserProfile />}
					
					
					
					2) 
					import { useDispatch } from 'react-redux';
					import { authActions } from '../store/auth';
					
					const dispatch = useDispatch();

				    const loginHandler = (event) => {
					event.preventDefault();

					dispatch(authActions.login());
				    };

					<form onSubmit={loginHandler}>
					  ...
					  <button>Login</button>
					</form>
					
					3) 
					  const dispatch = useDispatch();
					  const counter = useSelector((state) => state.counter.counter);
					  const show = useSelector((state) => state.counter.showCounter);

					  const incrementHandler = () => {
						dispatch(counterActions.increment());
					  };

					  const increaseHandler = () => {
						dispatch(counterActions.increase(10)); // { type: SOME_UNIQUE_IDENTIFIER, payload: 10 }
					  };

					  const decrementHandler = () => {
						dispatch(counterActions.decrement());
					  };

					  const toggleCounterHandler = () => {
						dispatch(counterActions.toggleCounter());
					  };
					  
					  
					  
					  
					  {show && <div className={classes.value}>{counter}</div>}
					  <div>
						<button onClick={incrementHandler}>Increment</button>
						<button onClick={increaseHandler}>Increase by 10</button>
						<button onClick={decrementHandler}>Decrement</button>
					  </div>
					  <button onClick={toggleCounterHandler}>Toggle Counter</button>

	************************************Advance Redux  **************************************
****************************************************************************************************************** 
					
					
		--> Reducer functions must be pure, side-effect free and synchronous.
			So, if your code has side-effects and asynchronous tasks, then either use useEffect() inside the component itself, or
			create your own action creators, and don't use the default provided by redux toolkit.

		--> If the logic/code for data transformation is synchronous and side-effect free, then prefer reducer functions, and 
			not action creator and Components.
		
			
			Using use effect with Redux ::
			
				import { useEffect } from 'react';
				import { useSelector } from 'react-redux';
				....
				...
				...

				function App() {
				  const showCart = useSelector((state) => state.ui.cartIsVisible);
				  const cart = useSelector((state) => state.cart);

				 // Using useEffect inside the component with the Http Request.
				  useEffect(() => {
					fetch('https://react-http-6b4a6.firebaseio.com/cart.json', {
					  method: 'PUT',
					  body: JSON.stringify(cart),
					});
				  }, [cart]);

				  return (
					<Layout>
					  {showCart && <Cart />}
					  <Products />
					</Layout>
				  );
				}

				export default App;
				
			
			Using Custom action creators in redux ::
			
				App.js file :
								
								import { Fragment, useEffect } from 'react';
								import { useSelector, useDispatch } from 'react-redux';
								..
								..
								..
								import { sendCartData, fetchCartData } from './store/cart-actions';

								let isInitial = true;

								function App() {
								  const dispatch = useDispatch();
								  const showCart = useSelector((state) => state.ui.cartIsVisible);
								  const cart = useSelector((state) => state.cart);
								  const notification = useSelector((state) => state.ui.notification);

								  useEffect(() => {
								  // calling custom action creator function.
									dispatch(fetchCartData());
								  }, [dispatch]);

								  useEffect(() => {
									if (isInitial) {
									  isInitial = false;
									  return;
									}

									if (cart.changed) {
									  dispatch(sendCartData(cart));
									}
								  }, [cart, dispatch]);

								  return (
									<Fragment>
									  {notification && (
										<Notification
										  status={notification.status}
										  title={notification.title}
										  message={notification.message}
										/>
									  )}
									  <Layout>
										{showCart && <Cart />}
										<Products />
									  </Layout>
									</Fragment>
								  );
								}

								export default App;
					
				
				ui-slice.js file :
								
								
								import { createSlice } from '@reduxjs/toolkit';

								const uiSlice = createSlice({
								  name: 'ui',
								  initialState: { cartIsVisible: false, notification: null },
								  reducers: {
									toggle(state) {
									  state.cartIsVisible = !state.cartIsVisible;
									},
									showNotification(state, action) {
									  state.notification = {
										status: action.payload.status,
										title: action.payload.title,
										message: action.payload.message,
									  };
									},
								  },
								});

								export const uiActions = uiSlice.actions;

								export default uiSlice;
								
				cart-slice.js file :
				
								
								import { createSlice } from '@reduxjs/toolkit';

								const cartSlice = createSlice({
								  name: 'cart',
								  initialState: {
									items: [],
									totalQuantity: 0,
									changed: false,
								  },
								  reducers: {
								  // The reducer functions should be prefered for the data manipulation logic, which is synchronous,
								  // and doesn't have any side effect. So, addItemToCart and removeItemFromCart reducer function below
								  // can be seen with data manipulation logic.
									replaceCart(state, action) {
									  state.totalQuantity = action.payload.totalQuantity;
									  state.items = action.payload.items;
									},
									addItemToCart(state, action) {
									  const newItem = action.payload;
									  const existingItem = state.items.find((item) => item.id === newItem.id);
									  state.totalQuantity++;
									  state.changed = true;
									  if (!existingItem) {
										state.items.push({
										  id: newItem.id,
										  price: newItem.price,
										  quantity: 1,
										  totalPrice: newItem.price,
										  name: newItem.title,
										});
									  } else {
										existingItem.quantity++;
										existingItem.totalPrice = existingItem.totalPrice + newItem.price;
									  }
									},
									removeItemFromCart(state, action) {
									  const id = action.payload;
									  const existingItem = state.items.find((item) => item.id === id);
									  state.totalQuantity--;
									  state.changed = true;
									  if (existingItem.quantity === 1) {
										state.items = state.items.filter((item) => item.id !== id);
									  } else {
										existingItem.quantity--;
										existingItem.totalPrice = existingItem.totalPrice - existingItem.price;
									  }
									},
								  },
								});

								export const cartActions = cartSlice.actions;

								export default cartSlice;
								
				
				cart-actions.js file :
				
								import { uiActions } from './ui-slice';
								import { cartActions } from './cart-slice';

								
								// fetchCartData is a custom action creator. This returns a function, and must be used when 
								// code logic async and has side-effects.
								// redux can handle actions which return functions. It calls the returned function for us.
								export const fetchCartData = () => {
								  return async (dispatch) => {
									const fetchData = async () => {
									  const response = await fetch(
										'https://react-http-6b4a6.firebaseio.com/cart.json'
									  );

									  if (!response.ok) {
										throw new Error('Could not fetch cart data!');
									  }

									  const data = await response.json();

									  return data;
									};

									try {
									  const cartData = await fetchData();
									  dispatch(
										cartActions.replaceCart({
										  items: cartData.items || [],
										  totalQuantity: cartData.totalQuantity,
										})
									  );
									} catch (error) {
									  dispatch(
										uiActions.showNotification({
										  status: 'error',
										  title: 'Error!',
										  message: 'Fetching cart data failed!',
										})
									  );
									}
								  };
								};

								
								// sendCartData is also a custom action creator.
								export const sendCartData = (cart) => {
								  return async (dispatch) => {
									dispatch(
									  uiActions.showNotification({
										status: 'pending',
										title: 'Sending...',
										message: 'Sending cart data!',
									  })
									);

									const sendRequest = async () => {
									  const response = await fetch(
										'https://react-http-6b4a6.firebaseio.com/cart.json',
										{
										  method: 'PUT',
										  body: JSON.stringify({
											items: cart.items,
											totalQuantity: cart.totalQuantity,
										  }),
										}
									  );

									  if (!response.ok) {
										throw new Error('Sending cart data failed.');
									  }
									};

									try {
									  await sendRequest();

									  dispatch(
										uiActions.showNotification({
										  status: 'success',
										  title: 'Success!',
										  message: 'Sent cart data successfully!',
										})
									  );
									} catch (error) {
									  dispatch(
										uiActions.showNotification({
										  status: 'error',
										  title: 'Error!',
										  message: 'Sending cart data failed!',
										})
									  );
									}
								  };
								};


	************************************creating multi-page SPA with React Router  **************************************
****************************************************************************************************************** 

		--> npm install react-router-dom@5



-- Newer Version of React Router DOM (v6) --- a new way of defining the routes

	App.js file ::
		import {createBrowserRouter, RouterProvider} from 'react-router-dom';
		import HomePage from './pages/home';

		const router = createBrowserRouter([
		{page: '/', element: <HomePage/>}
		]);

		function App() {
		return <RouterProvider router={router} />;
		}

		export default App;


-- to navigate the user to one of the routes, don't use anchor tag... Because it sends an http request to server and everything (js, html, css, etc.) are agin reloaded. This defeates the whole purpose of SPA.
-- instead use 'Link' provided by react-router-dom.


	Home.js file ::
		import {Link} from react-router-dom;
		function Homepage() {
		return <>
			<h1>Home Page</h1>
			<p>Go to <Link to="/products">products page</Link></p>
		       <>;
		
		}

--  Layouts and Nested Routes
-- 	Below example is to create a navigation bar on top of all the pages/routes.

	App.js file :: 

			import {createBrowserRouter, RouterProvider} from 'react-router-dom';
			
			const router = createBrowserRouter([
			  {
			    path: '/',
			    element: <RootLayout />,
			    children: [
			      { path: '/', element: <HomePage /> },
			      { path: '/products', element: <ProductsPage /> },
			    ],
			  }
			]);
			
			function App() {
			  return <RouterProvider router={router} />;
			}
			
			export default App;

	Root.js file ::

			import { Outlet } from 'react-router-dom';
			
			import MainNavigation from '../components/MainNavigation';
			import classes from './Root.module.css';
			
			function RootLayout() {
			  return (
			    <>
			      <MainNavigation /> // this is the navigation bar that has to be included on all pages/routes
			      <main className={classes.content}>
			        <Outlet /> // outlet marks the place where the children needs to be inserted
			      </main>
			    </>
			  );
			}
			
			export default RootLayout;

-- Addding error page
	
	App.js file ::

			...
			...
			...

			const router = createBrowserRouter([
			  {
			    path: '/',
			    element: <RootLayout />,
			    errorElement: <ErrorPage />,
			    children: [
			      { path: '/', element: <HomePage /> },
			      { path: '/products', element: <ProductsPage /> },
			    ],
			  }
			]);
			
			...
			...
			...

-- If want to show the clicked links in different style, then use NavLink and not Link... In classname instead of providing a class, provide a function which provides classes based on condition whether the link is active or not....

			     ...
			     <NavLink to="/products" className={({ isActive }) => isActive ? classes.active : undefined}>
		              Products
		            </NavLink>
			     ....
// added end attribute, so that this navlink is not always active.. and its active only if the path matches exactly to '/'
			      <NavLink to="/" className={({ isActive }) => isActive ? classes.active : undefined} end>
		              Products
		            </NavLink>

-- to navigate programmatically

			import { useNavigate } from 'react-router-dom';
			
			...
			...
			const navigate = useNavigate();
			....
			navigate('/products');
			...

-- dynamic routes (ex- having path params)
-- use colon and then the path param

			...
			...
			const router = createBrowserRouter([
			  {
			    path: '/',
			    element: <RootLayout />,
			    errorElement: <ErrorPage />,
			    children: [
			      { path: '/', element: <HomePage /> },
			      { path: '/products', element: <ProductsPage /> },
			      { path: '/products/:productId', element: <ProductDetailPage /> }
			    ],
			  }
			]);
			..
			..

-- using the passed params in the component (useParams hook)

	ProductsDetails.js file ::

			import { useParams } from 'react-router-dom';
			function ProductDetailPage() {
			  const params = useParams();
			
			  return (
			    <>
			      <h1>Product Details!</h1>
			      <p>{params.productId}</p>
			    </>
			  );
			}
			
			export default ProductDetailPage;


-- Absolute vs. Relative paths
	-- if path definition starts with '/', then its an absolute path. It will be appended to the url of the main app/ main domain name and not to the currently active 	   path/route.
	-- if a path doesn't start with '/', then its a relative path. It will be appended to the parent wrapper route.
	-- if working with 'Link' component and relative paths, then we can leverage 'relative' attribute of the 'Link' component. This attribute can be assigned 		  'path'/'route' as value. When 'path' is used then relative to the current path(in url), else if 'route' is used, then its relative to the parent route (defined 
           in the route definition in the createBrowserRouter)


-- index routes
	-- if for the parent route definition, we want to load any component, then we can either define the path as empty, or we can set the index property to true.

	App.js :: 

		const router = createBrowserRouter([
		  {
		    path: '/',
		    element: <RootLayout />,
		    errorElement: <ErrorPage />,
		    children: [
		      { index: true, element: <HomePage /> },
		      { path: 'products', element: <ProductsPage /> },
		      { path: 'products/:productId', element: <ProductDetailPage /> }
		    ],
		  }
		]);

-- We can also add another (nested) layout route within the main layout route (ex: '/events' route inside '/' route)
	App.js ::
		const router = createBrowserRouter([
		{
		    path: '/',
		    element: <RootLayout />,
		    children: [
		      { index: true, element: <HomePage /> },
		      {
		        path: 'events',
		        element: <EventsRootLayout />,
		        children: [
		          { index: true, element: <EventsPage /> },
		          { path: ':eventId', element: <EventDetailPage /> },
		          { path: 'new', element: <NewEventPage /> },
		          { path: ':eventId/edit', element: <EditEventPage /> },
		        ],
		      },
		    ],
		  },
		]);

	EventsRoot.js file ::
		import { Outlet } from 'react-router-dom';
		import EventsNavigation from '../components/EventsNavigation';
		
		function EventsRootLayout() {
		  return (
		    <>
		      <EventsNavigation />
		      <Outlet />
		    </>
		  );
		}
		
		export default EventsRootLayout;

----------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------- More Advance features of React Router DOM ----------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------

-- To fetch data, we can use react router loader. Earlier we have seen we can use useEffect for the same purpose. With React Router loader, we start fetching the data as 
   soon as the react router starts routing/navigating to the new route. The router will wait for the data to be loaded, before it actually starts rendering the page.
-- We can add the loader function in the route definition itself.
-- To fetch/get the data returned by the loader function inside the component, we can use 'useLoaderData' hook by react-router-dom
-- Even if your loader function id async and returns a promise, react-router-dom will check the return type and in the end return final data only.
-- To fetch data using the 'useLoaderData' hook, we can call/use it even inside any lower-level/child route component. But it will not work on higher-level.
-- Since the new page will not start rendering untill the data is fecthed by the loader function, the user will not see any feedback on the screen.
   So, to show some loader/feedback to user, we can use 'useNavigation' hook. This hook will tell us the state of the current routing/navigation (i.e. 
  idle/loading/submitting).


	App.js file ::
		import { RouterProvider, createBrowserRouter } from 'react-router-dom';
		import EventsPage, { loader as eventsLoader } from './pages/Events';
		...
		...
		
		const router = createBrowserRouter([
		  {
		    path: '/',
		    element: <RootLayout />,
		    children: [
		      { index: true, element: <HomePage /> },
		      {
		        path: 'events',
		        element: <EventsRootLayout />,
		        children: [
		          {
		            index: true,
		            element: <EventsPage />,
		            loader: eventsLoader,
		          },
		          { path: ':eventId', element: <EventDetailPage /> },
		          { path: 'new', element: <NewEventPage /> },
		          { path: ':eventId/edit', element: <EditEventPage /> },
		        ],
		      },
		    ],
		  },
		]);
		
		function App() {
		  return <RouterProvider router={router} />;
		}
		
		export default App;

	Events.js file ::
		import { useLoaderData } from 'react-router-dom';
		...
		...
		
		function EventsPage() {
		  const events = useLoaderData();
		
		  return <EventsList events={events} />;
		}
		
		export default EventsPage;

		// Although the loader is used in the App.js file, it should be defined in the corresponding component file only..
		export async function loader() {
		  const response = await fetch('http://localhost:8080/events');
		
		  if (!response.ok) {
		    // ...
		  } else {
		    const resData = await response.json();
		    return resData.events;
		  }
		}

	Root.js file ::
		import { Outlet, useNavigation } from 'react-router-dom';
		....
		....
		
		function RootLayout() {
		  const navigation = useNavigation();
		
		  return (
		    <>
		      <MainNavigation />
		      <main>
		         {navigation.state === 'loading' && <p>Loading...</p>} // this code checks the curent state of navigation, and shows the loader to user.
		        <Outlet />
		      </main>
		    </>
		  );
		}
		
		export default RootLayout;

-- We can even return Response object (built-in in modern browsers) from the loader function. So, there is no need to extract the data from the backend API response.
   We can directly return the entire response object itself.
-- Inside loader function, we can use any JS code. But, we can't use react hooks.

	ex :
		export async function loader() {
		  const response = await fetch('http://localhost:8080/events');
		
		  if (!response.ok) {
		    // ...
		  } else {
		    return response;
		  }
		}

-- To handle error status code sent by the API, we can directly throw error inside the loader function. Now, to handle this error, we can use 'errorElement' attribute
   in the route definition. The component defined will be shown whenever there is any error in the route or any child-route (if child-route doesn't have its own 	 
   errorElement)
   When throwing, we can also throw an response object. That way, we can be more specific about the status code and the error message.
   To get the thrown response object in the custom error page, we can use the 'useRouteError' hook.


	App.js file ::
		import { RouterProvider, createBrowserRouter } from 'react-router-dom';		
		...
		import EventDetailPage from './pages/EventDetail';
		import EventsPage, { loader as eventsLoader } from './pages/Events';
		...
		...
		
		const router = createBrowserRouter([
		  {
		    path: '/',
		    element: <RootLayout />,
		    errorElement: <ErrorPage />,
		    children: [
		      ....
		    ],
		  },
		]);
		
		function App() {
		  return <RouterProvider router={router} />;
		}
		
		export default App;


	Loader function throwing response object (either directly, or using a json helper function) ::
		export async function loader() {
		  const response = await fetch('http://localhost:8080/events');
		
		  if (!response.ok) {
		    // throw new Response(JSON.stringify({ message: 'Could not fetch events.' }), {
		    //   status: 500,
		    // });
		    // for json helper function, import json from 'react-router-dom'
		    throw json(
		      { message: 'Could not fetch events.' },
		      {
		        status: 500,
		      }
		    );
		  } else {
		    return response;
		  }
		}


	Error.js (Custom error page - useRouteError hook is used) ::
		import { useRouteError } from 'react-router-dom';
		...
		...
		function ErrorPage() {
		  const error = useRouteError();
		
		  let title = 'An error occurred!';
		  let message = 'Something went wrong!';

		// we can access status, if we are throwing a response object.
		  if (error.status === 500) {
		    message = JSON.parse(error.data).message;
		  }
		
		  if (error.status === 404) {
		    title = 'Not found!';
		    message = 'Could not find resource or page.';
		  }
		
		  return (
		    <>
		      <MainNavigation />
		      <PageContent title={title}>
		        <p>{message}</p>
		      </PageContent>
		    </>
		  );
		}
		
		export default ErrorPage;

-- react router when calling the loader function passes an object with two properties - request and params. These properties can be used in case of the dynamic routes.
-- request property can be used to get url/query parameters, etc.
-- params can be used to get path params.

		export async function loader({request, params}) {
		  const id = params.eventId;
		  const response = await fetch('http://localhost:8080/events/' + id);
		  if (!response.ok) {
		    throw json({message: 'Could not fetch details for selected event.'}, {
		      status: 500
		    })
		  } else {
		    return response;
		  }
		}

-- If we want to access data from a loader function which is not directly defined in that same route, but in any of the parent routes. Then instead of useLoaderData hook, 
   we can use useRouteLoaderData hook... This hook works similar to the useLoaderData, but takes an additional argument 'route-id'.

	App.js file ::
		...
		...
		
		const router = createBrowserRouter([
		  {
		    ...
		    children: [
		      { index: true, element: <HomePage /> },
		      {
		        ....
		          {
		            path: ':eventId',
		            id: 'event-detail', // this same id needs to be passed in the useRouteLoaderData hook
		            loader: eventDetailLoader,
		            children: [
		              {
		                index: true,
		                element: <EventDetailPage />,
		              },
		              { path: 'edit', element: <EditEventPage /> },
		            ],
		          },
		          { path: 'new', element: <NewEventPage /> },
		        ],
		      },
		    ],
		  },
		]);
		
		....
		
		export default App;

	EditEvent.js file ::
		import { useRouteLoaderData } from 'react-router-dom';
		import EventForm from '../components/EventForm';
		
		function EditEventPage() {
		  const data = useRouteLoaderData('event-detail');
		
		  return <EventForm event={data.event} />;
		}
		
		export default EditEventPage;



	

	





	
					







	App.js File :
		
		import { Route, Switch, Redirect } from 'react-router-dom';
		
		<Switch>
        <Route path='/' exact>
          <Redirect to='/quotes' />
        </Route>
        <Route path='/quotes' exact>
          <AllQuotes />
        </Route>
        <Route path='/quotes/:quoteId'>
          <QuoteDetail />
        </Route>
        <Route path='/new-quote'>
          <NewQuote />
        </Route>
        <Route path='*'>
          <NotFound />
        </Route>
      </Switch>
	  
	  
	  index.js file : 
		import ReactDOM from 'react-dom';
		import { BrowserRouter } from 'react-router-dom';

		import './index.css';
		import App from './App';

		ReactDOM.render(
		  <BrowserRouter>
			<App />
		  </BrowserRouter>,
		  document.getElementById('root')
		);
		
	
		To send user to a url  (use NavLink or Link):
		
		import { NavLink } from 'react-router-dom';
		<NavLink to='/new-quote' activeClassName={classes.active}>
              Add a Quote
        </NavLink>
		
		
		Programatically sending a user to a url (useHistory hook can be used) :
		
		  import { useHistory, useLocation } from 'react-router-dom';
		  const history = useHistory();
		  const location = useLocation();

		  const queryParams = new URLSearchParams(location.search); // "URLSearchParams" function is provided by JS.

		  const isSortingAscending = queryParams.get('sort') === 'asc'; // to get query params we can use useLocation() hook.

		  const sortedQuotes = sortQuotes(props.quotes, isSortingAscending);

		  const changeSortingHandler = () => {
			// you can use either history.push or history.replace method.
			history.push({
			  pathname: location.pathname,
			  search: `?sort=${(isSortingAscending ? 'desc' : 'asc')}`
			});
		  };
		  
		  
		
			  import { useParams, Route, Link, useRouteMatch } from 'react-router-dom';
			  const match = useRouteMatch(); // To make the  nested route definition more flexible, and less error prone.
			  // match.path gives the route path definition.
			  // match.url gives the actual current url.
			  const params = useParams(); // To use path params, we can use "useParams" hook.

			  const { quoteId } = params; //  path definition : "/quotes/:quoteId"
		  
			  ..
			  ...
			  ...
			  ...
				<Route path={match.path} exact>
				<div className='centered'>
				  <Link className='btn--flat' to={`${match.url}/comments`}>
					Load Comments
				  </Link>
				</div>
			  </Route>
			  <Route path={`${match.path}/comments`}>
				<Comments />
			  </Route>
			  
		

	************************************ Deploying React Application **************************************
****************************************************************************************************************** 
		--> Steps :
					 Testing
						|
						|
						v
			Optimization (ex: lazy loading, React Memo)
						|
						|
						v
			Build Application for Production
						|
						|
						v
			Upload production code to Production server
						|
						|
						v
				Configure Server
	   
					
					
			
					
